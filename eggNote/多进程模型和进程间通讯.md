# node.js Cluster模块
* 在服务器上同时启动多个进程。
* 每个进程里面都跑的是同一份源代码(好比把以前一个进程的工作分给多个进程出做)。
* 更神奇的是,这些进程可以同时监听一个端口
* [Cluster 实现原理](https://cnodejs.org/topic/56e84480833b7c8a0492e20c)
* 其中：
* 负责启动其他进程的叫做Master进程,他好比是个包工头,不做具体的工作,只负责启动其他进程。
* 其他被启动的叫Worker进程,顾名思意就是干活的工人。它们接受请求,对外提供服务。
* Worker进程的数量一般根据服务器的CPU核数来定,这样就可以完美利用多核资源。
# 框架的多进程模型
## 进程守护
### 未捕获异常
* 当代码抛出了异常没有被异常捕获到时,进程将会被退出,此时Node.js提供了process.on('uncaughtException',handler)接口来捕获它,但是当一个Worker进程遇到未捕获的异常时,它已经处于一个不确定状态,此时我们应该让这个进程优雅退出：
1.  关闭异常Worker进程所有的TCP Server(将已有的连接快速断开,且不再接受新的连接),断开和Maser的IPC通道,不再接受新的用户请求。
2.  Master立刻fork一个新的Worker进程,保证在线的工人总数不变。
3.  异常Worker等待一段时间,处理完已经接受的请求后退出。
### OOM、系统异常
* 而当一个进程出现异常导致crash或者OOM(申请的内存过大,导致异常)被系统杀死时,不像未捕获异常发生时我们还有机会让进程继续执行,只能够让当前进程直接退出,Master立刻fork一个新的Worker。
* 在框架里,采用graceful和egg-cluster两个模块配合实现上面的逻辑。这套方案已在阿里巴巴和蚂蚁金服的生产环境广泛部署，且经受过『双11』大促的考验，所以是相对稳定和靠谱的。